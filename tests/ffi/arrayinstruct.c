/* Automatically generated by chibi-ffi; version: 0.3 */

#include <chibi/eval.h>

#include <stdlib.h>

struct v2 {
    float vals[2];
};
/*
types: (v2)
enums: ()
*/

sexp sexp_make_v2_stub (sexp ctx, sexp self, sexp_sint_t n, sexp arg0) {
  struct v2* r;
  sexp_gc_var1(res);
  sexp_gc_preserve1(ctx, res);
  res = sexp_alloc_tagged(ctx, sexp_sizeof(cpointer), sexp_unbox_fixnum(sexp_opcode_return_type(self)));
  sexp_cpointer_value(res) = calloc(1, sizeof(struct v2));
  r = (struct v2*) sexp_cpointer_value(res);
  memset(r, 0, sizeof(struct v2));
  sexp_freep(res) = 1;
  for(unsigned i = 0; i < 2; i++) {
    ((struct v2*)sexp_cpointer_value(res))->vals[i] = sexp_flonum_value(sexp_vector_ref(arg0, sexp_make_fixnum(i)));
  }
  sexp_gc_release1(ctx);
  return res;
}

sexp sexp_v2_get_vals (sexp ctx, sexp self, sexp_sint_t n, sexp x) {
  if (! (sexp_pointerp(x) && (sexp_pointer_tag(x) == sexp_unbox_fixnum(sexp_opcode_arg1_type(self)))))
    return sexp_type_exception(ctx, self, sexp_unbox_fixnum(sexp_opcode_arg1_type(self)), x);
  sexp_gc_var1(res);
  sexp_gc_preserve1(ctx, res);
  res = sexp_make_vector(ctx, sexp_make_fixnum(2), SEXP_ZERO);
  for(unsigned i = 0; i < 2; i++) {
    sexp e = sexp_make_flonum(ctx, ((struct v2*)sexp_cpointer_value(x))->vals[i]);
    sexp_vector_set(res, sexp_make_fixnum(i), e);
  }
}

sexp sexp_v2_set_vals (sexp ctx, sexp self, sexp_sint_t n, sexp x, sexp v) {
  if (! (sexp_pointerp(x) && (sexp_pointer_tag(x) == sexp_unbox_fixnum(sexp_opcode_arg1_type(self)))))
    return sexp_type_exception(ctx, self, sexp_unbox_fixnum(sexp_opcode_arg1_type(self)), x);
sexp res;
  if (!sexp_listp(ctx, v)      || sexp_unbox_fixnum(sexp_length(ctx, v)) != 2)
    return sexp_type_exception(ctx, self, SEXP_PAIR, v);
  for (res=v; sexp_pairp(res); res=sexp_cdr(res))
    if (! sexp_flonump(sexp_car(res)))
      return sexp_xtype_exception(ctx, self, "not a list of flonums", v);
  for(unsigned i = 0; i < 2; i++) {
    ((struct v2*)sexp_cpointer_value(x))->vals[i] = sexp_flonum_value(sexp_vector_ref(v, sexp_make_fixnum(i)));
  }
  return SEXP_VOID;
}


sexp sexp_init_library (sexp ctx, sexp self, sexp_sint_t n, sexp env, const char* version, const sexp_abi_identifier_t abi) {
  sexp sexp_v2_type_obj;
  sexp_gc_var3(name, tmp, op);
  if (!(sexp_version_compatible(ctx, version, sexp_version)
        && sexp_abi_compatible(ctx, abi, SEXP_ABI_IDENTIFIER)))
    return SEXP_ABI_ERROR;
  sexp_gc_preserve3(ctx, name, tmp, op);
  name = sexp_c_string(ctx, "v2", -1);
  sexp_v2_type_obj = sexp_register_c_type(ctx, name, sexp_finalize_c_type);
  tmp = sexp_string_to_symbol(ctx, name);
  sexp_env_define(ctx, env, tmp, sexp_v2_type_obj);
  sexp_type_slots(sexp_v2_type_obj) = SEXP_NULL;
  sexp_push(ctx, sexp_type_slots(sexp_v2_type_obj), sexp_intern(ctx, "vals", -1));
  sexp_type_getters(sexp_v2_type_obj) = sexp_make_vector(ctx, SEXP_ONE, SEXP_FALSE);
  sexp_type_setters(sexp_v2_type_obj) = sexp_make_vector(ctx, SEXP_ONE, SEXP_FALSE);
  tmp = sexp_make_type_predicate(ctx, name, sexp_v2_type_obj);
  name = sexp_intern(ctx, "v2?", 3);
  sexp_env_define(ctx, env, name, tmp);
  op = sexp_define_foreign(ctx, env, "v2-vals-set!", 2, sexp_v2_set_vals);
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = sexp_make_fixnum(SEXP_FLONUM);
    sexp_opcode_arg1_type(op) = sexp_make_fixnum(sexp_type_tag(sexp_v2_type_obj));
    sexp_opcode_arg2_type(op) = sexp_make_fixnum(SEXP_FLONUM);
  }
  if (sexp_vectorp(sexp_type_setters(sexp_v2_type_obj))) sexp_vector_set(sexp_type_setters(sexp_v2_type_obj), SEXP_ZERO, op);
  op = sexp_define_foreign(ctx, env, "v2-vals", 1, sexp_v2_get_vals);
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = sexp_make_fixnum(SEXP_FLONUM);
    sexp_opcode_arg1_type(op) = sexp_make_fixnum(sexp_type_tag(sexp_v2_type_obj));
  }
  if (sexp_vectorp(sexp_type_getters(sexp_v2_type_obj))) sexp_vector_set(sexp_type_getters(sexp_v2_type_obj), SEXP_ZERO, op);
  op = sexp_define_foreign(ctx, env, "make-v2", 1, sexp_make_v2_stub);
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = sexp_make_fixnum(sexp_type_tag(sexp_v2_type_obj));
    sexp_opcode_arg1_type(op) = sexp_make_fixnum(SEXP_FLONUM);
  }
  sexp_gc_release3(ctx);
  return SEXP_VOID;
}

